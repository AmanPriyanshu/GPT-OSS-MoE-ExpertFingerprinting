<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPT-OSS MoE Expert Analytics</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container { max-width: 1400px; margin: 0 auto; }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        .header h1 { font-size: 2.5rem; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }

        .controls {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }

        .control-group h3 { margin-bottom: 10px; }
        
        select, input { 
            padding: 8px; 
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        input[type="radio"] {
            width: auto;
            margin-right: 8px;
            margin-left: 0;
        }

        label {
            display: flex;
            align-items: center;
            margin: 5px 0;
            cursor: pointer;
        }

        .radio-group {
            display: flex;
            flex-direction: column;
        }

        .analyze-btn {
            grid-column: 1 / -1;
            padding: 15px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            cursor: pointer;
            margin-top: 15px;
        }

        .analyze-btn:disabled { opacity: 0.5; }

        .results {
            background: white;
            border-radius: 15px;
            padding: 25px;
            display: none;
        }

        .sample-count {
            text-align: center;
            font-size: 1.2rem;
            margin-bottom: 25px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .token-visualization {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            border-left: 5px solid #667eea;
        }

        .viz-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .viz-badge {
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .token-paragraph {
            line-height: 2.2;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 1rem;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
        }

        .token {
            display: inline-block;
            padding: 8px 12px;
            margin: 3px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            font-size: 1rem;
        }

        .token:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            border-color: rgba(255,255,255,0.5);
        }

        .token:active { transform: scale(0.95); }

        .token.short { min-width: 40px; font-size: 0.9rem; }
        .token.medium { min-width: 70px; font-size: 1rem; }
        .token.long { min-width: 100px; font-size: 1.1rem; }
        .token.very-long { min-width: 130px; font-size: 1.2rem; }

        .punctuation {
            background: #6c757d !important;
            min-width: 30px !important;
            font-size: 1rem !important;
        }

        .space-token {
            background: transparent !important;
            color: #999 !important;
            border: 1px dashed #ccc !important;
            min-width: 20px !important;
            font-size: 0.8rem !important;
        }

        .top4-section {
            margin-bottom: 25px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .top4-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .download-btn {
            padding: 8px 15px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .top4-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .layer-card {
            background: white;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
            text-align: center;
        }

        .layer-title { font-weight: bold; margin-bottom: 8px; }
        .expert-list { font-size: 0.9rem; }

        .charts-section {
            margin-bottom: 25px;
        }

        .chart-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }

        .chart-grid {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .layer-chart {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            height: 200px;
        }

        .layer-chart canvas {
            width: 100% !important;
            height: 150px !important;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 2rem;
            cursor: pointer;
            color: #666;
            line-height: 1;
        }

        .close-btn:hover { color: #333; }

        .layer-breakdown {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .layer-breakdown .layer-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            border-left: 4px solid #667eea;
            text-align: left;
        }

        .layer-breakdown .layer-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #333;
        }

        .layer-breakdown .expert-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .expert-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: white;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        .expert-id { font-weight: 600; }
        .expert-prob { color: #666; font-size: 0.8rem; }

        @media (max-width: 768px) {
            .controls { grid-template-columns: 1fr; }
            .top4-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>GPT-OSS MoE Expert Analytics</h1>
        </div>

        <div class="controls">
            <div class="control-group">
                <h3>Dataset</h3>
                <select id="dataset">
                    <option value="">Select dataset...</option>
                </select>
            </div>

            <div class="control-group">
                <h3>Category</h3>
                <div id="categories">Please select a dataset first</div>
            </div>

            <div class="control-group">
                <h3>Filter</h3>
                <div class="radio-group">
                    <label><input type="radio" name="filter" value="all" checked> All</label>
                    <label><input type="radio" name="filter" value="completed"> Completed Only</label>
                    <label><input type="radio" name="filter" value="incomplete"> Incomplete Only</label>
                </div>
            </div>

            <button class="analyze-btn" id="analyzeBtn" disabled>Analyze</button>
        </div>

        <div class="results" id="results"></div>
    </div>

    <script>
        const BASE_URL = 'https://amanpriyanshu.github.io/GPT-OSS-MoE-ExpertFingerprinting/data';
        let mapData = {};
        let charts = [];

        // Initialize
        async function init() {
            try {
                const response = await fetch(`${BASE_URL}/map.json`);
                mapData = await response.json();
                
                const select = document.getElementById('dataset');
                Object.keys(mapData).forEach(dataset => {
                    const option = document.createElement('option');
                    option.value = dataset;
                    option.textContent = dataset.replace(/_/g, ' ');
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to load data:', error);
            }
        }

        // Update categories when dataset changes
        document.getElementById('dataset').addEventListener('change', function() {
            const categories = document.getElementById('categories');
            const dataset = this.value;
            
            if (!dataset) {
                categories.innerHTML = 'Please select a dataset first';
                updateButton();
                return;
            }

            categories.innerHTML = '';
            Object.keys(mapData[dataset]).forEach((category, i) => {
                const label = document.createElement('label');
                const input = document.createElement('input');
                input.type = 'radio';
                input.name = 'category';
                input.value = category;
                
                label.appendChild(input);
                label.appendChild(document.createTextNode(' ' + category));
                categories.appendChild(label);
            });

            categories.addEventListener('change', updateButton);
            updateButton();
        });

        function updateButton() {
            const dataset = document.getElementById('dataset').value;
            const category = document.querySelector('input[name="category"]:checked');
            document.getElementById('analyzeBtn').disabled = !dataset || !category;
        }

        // Main analysis function
        async function analyze() {
            const dataset = document.getElementById('dataset').value;
            const category = document.querySelector('input[name="category"]:checked')?.value;
            const filter = document.querySelector('input[name="filter"]:checked')?.value;

            if (!dataset || !category) return;

            const results = document.getElementById('results');
            results.innerHTML = '<div style="text-align: center; padding: 40px;">Loading...</div>';
            results.style.display = 'block';

            try {
                // Load and merge data
                const data = await loadData(dataset, category, filter);
                const totalSamples = data.reduce((sum, item) => sum + item.sample_count, 0);

                if (totalSamples === 0) {
                    results.innerHTML = '<div style="text-align: center; padding: 40px;">No data found</div>';
                    return;
                }

                // Clear old charts
                charts.forEach(chart => chart.destroy());
                charts = [];

                // Build results HTML
                const tokenViz = await createTokenVisualization(dataset, category, filter);
                
                results.innerHTML = `
                    <div class="sample-count">
                        Analyzing <strong>${totalSamples.toLocaleString()}</strong> samples
                    </div>

                    ${tokenViz}

                    ${createTop4Section(data, 'think_expert_analytics', 'Think Tokens')}
                    ${createTop4Section(data, 'answer_expert_analytics', 'Answer Tokens')}
                    
                    <div class="charts-section">
                        <div class="chart-title">Think Token Expert Patterns</div>
                        <div id="thinkCharts" class="chart-grid"></div>
                    </div>

                    <div class="charts-section">
                        <div class="chart-title">Answer Token Expert Patterns</div>
                        <div id="answerCharts" class="chart-grid"></div>
                    </div>
                `;

                // Add modal to body
                if (!document.getElementById('layerModal')) {
                    document.body.insertAdjacentHTML('beforeend', `
                        <div class="modal" id="layerModal">
                            <div class="modal-content">
                                <button class="close-btn" onclick="closeModal()">&times;</button>
                                <h2 id="modalTitle">Token Layer Breakdown</h2>
                                <div class="layer-breakdown" id="layerBreakdown"></div>
                            </div>
                        </div>
                    `);
                }

                // Setup downloads
                setupDownload('downloadThinkTokens', getTop4Data(data, 'think_expert_analytics'), 'think');
                setupDownload('downloadAnswerTokens', getTop4Data(data, 'answer_expert_analytics'), 'answer');

                // Create charts
                createCharts('thinkCharts', data, 'think_expert_analytics');
                createCharts('answerCharts', data, 'answer_expert_analytics');

            } catch (error) {
                console.error('Analysis failed:', error);
                results.innerHTML = '<div style="text-align: center; padding: 40px; color: red;">Analysis failed</div>';
            }
        }

        async function loadData(dataset, category, filter) {
            const categoryData = mapData[dataset][category];
            const merged = { completed: [], incomplete: [] };

            for (const [combo, info] of Object.entries(categoryData)) {
                const [finished, repetition] = combo.split('_');
                
                if (filter === 'completed' && finished !== 'True') continue;
                if (filter === 'incomplete' && finished !== 'False') continue;

                try {
                    const url = `${BASE_URL}/${dataset}/${encodeURIComponent(category)}/${combo}.json`;
                    const response = await fetch(url);
                    if (response.ok) {
                        const data = await response.json();
                        const group = finished === 'True' ? 'completed' : 'incomplete';
                        merged[group].push(data);
                    }
                } catch (e) {
                    console.warn('Failed to load:', combo);
                }
            }

            // Merge each group
            const result = [];
            Object.entries(merged).forEach(([status, items]) => {
                if (items.length === 0) return;

                const totalSamples = items.reduce((sum, item) => sum + item.sample_count, 0);
                const mergedItem = {
                    sample_count: totalSamples,
                    status: status,
                    think_expert_analytics: mergeAnalytics(items, 'think_expert_analytics'),
                    answer_expert_analytics: mergeAnalytics(items, 'answer_expert_analytics')
                };
                result.push(mergedItem);
            });

            return result;
        }

        function mergeAnalytics(items, key) {
            const merged = {};
            const totalSamples = items.reduce((sum, item) => sum + item.sample_count, 0);

            items.forEach(item => {
                if (!item[key]) return;
                const weight = item.sample_count / totalSamples;

                Object.entries(item[key]).forEach(([layer, experts]) => {
                    if (!merged[layer]) merged[layer] = {};
                    Object.entries(experts).forEach(([expert, metrics]) => {
                        if (!merged[layer][expert]) {
                            merged[layer][expert] = { count_frequency: 0 };
                        }
                        merged[layer][expert].count_frequency += metrics.count_frequency * weight;
                    });
                });
            });

            return merged;
        }

        async function createTokenVisualization(dataset, category, filter) {
            try {
                // Determine priority order based on filter
                let priorityOrder = [];
                
                if (filter === 'all') {
                    priorityOrder = ['True_False', 'False_False', 'True_True', 'False_True'];
                } else if (filter === 'completed') {
                    priorityOrder = ['True_False', 'True_True', 'False_False', 'False_True'];
                } else if (filter === 'incomplete') {
                    priorityOrder = ['False_False', 'False_True', 'True_False', 'True_True'];
                }
                
                // Try to load examples in priority order
                let exampleData = null;
                let usedFile = '';
                
                for (const combo of priorityOrder) {
                    try {
                        const exampleUrl = `${BASE_URL}/${dataset}/${encodeURIComponent(category)}/${combo}_examples.json`;
                        const response = await fetch(exampleUrl);
                        
                        if (response.ok) {
                            exampleData = await response.json();
                            usedFile = combo;
                            console.log(`Loaded examples from: ${combo}_examples.json`);
                            break;
                        }
                    } catch (e) {
                        console.warn(`Failed to load ${combo}_examples.json`);
                        continue;
                    }
                }
                
                if (!exampleData) {
                    return '<div class="token-visualization"><p>No example data available</p></div>';
                }
                
                // Parse the file type for display
                const [completed, repetition] = usedFile.split('_');
                const statusText = completed === 'True' ? 'Completed' : 'Incomplete';
                const repText = repetition === 'False' ? 'No Repetition' : 'With Repetition';
                
                // Separate think and answer tokens
                const { thinkTokens, answerTokens } = separateThinkAndAnswerTokens(exampleData);
                
                let visualizationHTML = `
                    <div style="margin-bottom: 10px; font-size: 0.9rem; color: #666; text-align: center;">
                        Source: ${usedFile}_examples.json (${statusText}, ${repText})
                    </div>
                `;
                
                // Think tokens section
                if (thinkTokens.tokens.length > 0) {
                    visualizationHTML += `
                        <div class="token-visualization">
                            <div class="viz-title">
                                Think Tokens Sequence
                                <span class="viz-badge">${thinkTokens.tokens.length} tokens</span>
                            </div>
                            <div class="token-paragraph">
                                ${createTokenElements(thinkTokens, exampleData.router_data)}
                            </div>
                        </div>
                    `;
                }
                
                // Answer tokens section
                if (answerTokens.tokens.length > 0) {
                    visualizationHTML += `
                        <div class="token-visualization">
                            <div class="viz-title">
                                Answer Tokens Sequence
                                <span class="viz-badge">${answerTokens.tokens.length} tokens</span>
                            </div>
                            <div class="token-paragraph">
                                ${createTokenElements(answerTokens, exampleData.router_data)}
                            </div>
                        </div>
                    `;
                }
                
                return visualizationHTML;
                
            } catch (error) {
                console.error('Failed to load example data:', error);
                return '<div class="token-visualization"><p>Example data unavailable</p></div>';
            }
        }

        function separateThinkAndAnswerTokens(exampleData) {
            if (!exampleData.generated_only) {
                return { thinkTokens: { tokens: [], startIdx: 0 }, answerTokens: { tokens: [], startIdx: 0 } };
            }

            const tokens = exampleData.generated_only;
            let thinkStartIdx = -1;
            let thinkEndIdx = -1;
            let answerStartIdx = -1;
            let answerEndIdx = tokens.length;

            // Find think tokens: between <|channel|>analysis<|message|> and <|end|>
            for (let i = 0; i < tokens.length - 2; i++) {
                if (tokens[i] === '<|channel|>' && tokens[i + 1] === 'analysis' && tokens[i + 2] === '<|message|>') {
                    thinkStartIdx = i + 3;
                }
                if (tokens[i] === '<|end|>' && thinkStartIdx !== -1 && thinkEndIdx === -1) {
                    thinkEndIdx = i;
                }
            }

            // Find answer tokens: between <|channel|>final<|message|> and end of sequence
            for (let i = 0; i < tokens.length - 2; i++) {
                if (tokens[i] === '<|channel|>' && tokens[i + 1] === 'final' && tokens[i + 2] === '<|message|>') {
                    answerStartIdx = i + 3;
                    break;
                }
            }

            // If we can't find proper boundaries, include all tokens as think tokens
            if (thinkStartIdx === -1) {
                thinkStartIdx = 0;
                thinkEndIdx = tokens.length;
            }

            const thinkTokens = {
                tokens: thinkStartIdx !== -1 && thinkEndIdx !== -1 ? 
                    tokens.slice(thinkStartIdx, thinkEndIdx) : [],
                startIdx: thinkStartIdx !== -1 ? thinkStartIdx : 0
            };

            const answerTokens = {
                tokens: answerStartIdx !== -1 ? 
                    tokens.slice(answerStartIdx, answerEndIdx) : [],
                startIdx: answerStartIdx !== -1 ? answerStartIdx : 0
            };

            console.log('Token separation:', {
                totalTokens: tokens.length,
                thinkStart: thinkStartIdx,
                thinkEnd: thinkEndIdx,
                thinkCount: thinkTokens.tokens.length,
                answerStart: answerStartIdx,
                answerEnd: answerEndIdx,
                answerCount: answerTokens.tokens.length
            });

            return { thinkTokens, answerTokens };
        }

        function createTokenElements(tokenData, routerData) {
            if (!tokenData.tokens || tokenData.tokens.length === 0) {
                return '<span class="token medium">No tokens available</span>';
            }

            const tokens = tokenData.tokens;
            const startIdx = tokenData.startIdx;
            
            // Create a map of token indices to router data
            const tokenRouterMap = {};
            let routerStartIdx = null;
            
            if (routerData) {
                routerData.forEach(tokenDataEntry => {
                    Object.keys(tokenDataEntry).forEach(tokenKey => {
                        const tokenIdx = parseInt(tokenKey.split('_')[1]);
                        tokenRouterMap[tokenIdx] = tokenDataEntry[tokenKey];
                        
                        // Find the minimum router index to determine offset
                        if (routerStartIdx === null || tokenIdx < routerStartIdx) {
                            routerStartIdx = tokenIdx;
                        }
                    });
                });
            }

            // Calculate the offset between our token indices and router indices
            // Router data starts from where generation begins, not from token 0
            const routerOffset = routerStartIdx !== null ? routerStartIdx - startIdx : 0;

            console.log('Router mapping info:', {
                tokenStartIdx: startIdx,
                routerStartIdx: routerStartIdx,
                routerOffset: routerOffset,
                tokenCount: tokens.length,
                sampleRouterKeys: Object.keys(tokenRouterMap).slice(0, 5)
            });

            return tokens.map((token, relativeIdx) => {
                const absoluteIdx = startIdx + relativeIdx;
                const routerIdx = absoluteIdx + routerOffset;
                const cleanToken = token.replace(/[<>|]/g, '');
                
                // Skip special tokens and empty tokens
                if (token.includes('<|') || token.includes('|>') || cleanToken.trim() === '') {
                    return '';
                }
                
                // Determine size class based on token length
                let sizeClass = 'medium';
                if (cleanToken.length <= 2) sizeClass = 'short';
                else if (cleanToken.length <= 5) sizeClass = 'medium';
                else if (cleanToken.length <= 8) sizeClass = 'long';
                else sizeClass = 'very-long';
                
                // Handle punctuation
                if (/^[.,!?;:(){}[\]"']$/.test(cleanToken)) {
                    return `<span class="token punctuation">${cleanToken}</span>`;
                }
                
                // Get router data for this token using corrected index
                const routerInfo = tokenRouterMap[routerIdx];
                let avgExpert = 15; // Default middle expert
                let layerData = {};
                
                if (routerInfo) {
                    // Calculate average expert across all layers
                    let totalExpert = 0;
                    let layerCount = 0;
                    
                    Object.entries(routerInfo).forEach(([layerKey, layerInfo]) => {
                        if (layerInfo.selected_experts && layerInfo.selected_experts.length > 0) {
                            const topExpert = layerInfo.selected_experts[0]; // Use top expert
                            totalExpert += topExpert;
                            layerCount++;
                            
                            layerData[layerKey] = {
                                experts: layerInfo.selected_experts.slice(0, 4),
                                probs: layerInfo.selected_probs.slice(0, 4)
                            };
                        }
                    });
                    
                    if (layerCount > 0) {
                        avgExpert = totalExpert / layerCount;
                    }
                } else {
                    // Only log missing data for the first few tokens to avoid spam
                    if (relativeIdx < 5) {
                        console.warn(`No router data for token "${cleanToken}" at token_idx:${absoluteIdx} router_idx:${routerIdx}`);
                    }
                }
                
                // Generate color based on expert
                const expertColor = getExpertColor(avgExpert);
                
                // Escape the token text and layer data for HTML attributes
                const escapedToken = cleanToken.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                const escapedLayerData = JSON.stringify(layerData).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                
                return `<span class="token ${sizeClass}" 
                            style="background: ${expertColor};" 
                            data-token="${escapedToken}"
                            data-layer-data='${escapedLayerData}'
                            data-router-idx="${routerIdx}"
                            onclick="showTokenBreakdown('${escapedToken}', this)">${cleanToken}</span>`;
            }).filter(token => token !== '').join('');
        }

        function getExpertColor(expertId) {
            const ratio = expertId / 31;
            const hue = 270 - (ratio * 150); // Purple to green
            const saturation = 70 + (ratio * 20);
            const lightness = 45 + (ratio * 15);
            return `hsla(${hue}, ${saturation}%, ${lightness}%, 0.9)`;
        }

        function showTokenBreakdown(tokenText, element) {
            const modal = document.getElementById('layerModal');
            const title = document.getElementById('modalTitle');
            const breakdown = document.getElementById('layerBreakdown');
            
            if (!modal) return;
            
            title.textContent = `Layer Breakdown for "${tokenText}"`;
            
            // Get layer data from element
            const layerDataStr = element.getAttribute('data-layer-data');
            let layerData = {};
            
            try {
                layerData = JSON.parse(layerDataStr || '{}');
            } catch (e) {
                console.warn('Failed to parse layer data');
            }
            
            // Generate layer cards
            let layerHTML = '';
            
            for (let i = 0; i < 24; i++) {
                const layerKey = `layer_${i}`;
                const layerInfo = layerData[layerKey];
                
                if (layerInfo && layerInfo.experts) {
                    layerHTML += `
                        <div class="layer-card">
                            <div class="layer-title">Layer ${i}</div>
                            <div class="expert-list">
                                ${layerInfo.experts.map((expert, idx) => `
                                    <div class="expert-item">
                                        <span class="expert-id" style="color: ${getExpertColor(expert)};">E${expert}</span>
                                        <span class="expert-prob">${layerInfo.probs[idx].toFixed(3)}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                } else {
                    layerHTML += `
                        <div class="layer-card">
                            <div class="layer-title">Layer ${i}</div>
                            <div class="expert-list" style="text-align: center; color: #999; font-style: italic;">
                                No data
                            </div>
                        </div>
                    `;
                }
            }
            
            breakdown.innerHTML = layerHTML;
            modal.style.display = 'flex';
        }

        function closeModal() {
            const modal = document.getElementById('layerModal');
            if (modal) modal.style.display = 'none';
        }

        function createTop4Section(data, analyticsKey, title) {
            const top4Data = getTop4Data(data, analyticsKey);
            const hasData = Object.keys(top4Data).length > 0;
            
            if (!hasData) {
                return `
                    <div class="top4-section">
                        <div class="top4-header">
                            <h3>${title} - Top 4 Expert Rankings</h3>
                        </div>
                        <div style="text-align: center; color: #666;">No data available</div>
                    </div>
                `;
            }

            const layerCards = Object.entries(top4Data)
                .map(([layer, experts]) => {
                    const layerNum = layer.replace('layer_', '');
                    const expertList = experts
                        .map(e => `E${e.expert} (${e.value.toFixed(3)})`)
                        .join(' > ');
                    
                    return `
                        <div class="layer-card">
                            <div class="layer-title">Layer ${layerNum}</div>
                            <div class="expert-list">${expertList}</div>
                        </div>
                    `;
                })
                .join('');

            return `
                <div class="top4-section">
                    <div class="top4-header">
                        <h3>${title} - Top 4 Expert Rankings</h3>
                        <button class="download-btn" id="download${title.replace(/\s+/g, '')}">Download JSON</button>
                    </div>
                    <div class="top4-grid">${layerCards}</div>
                </div>
            `;
        }

        function getTop4Data(data, analyticsKey) {
            const layerData = {};

            for (let i = 0; i < 24; i++) {
                const layerKey = `layer_${i}`;
                const experts = [];

                data.forEach(item => {
                    if (item[analyticsKey] && item[analyticsKey][layerKey]) {
                        const weight = item.sample_count;
                        Object.entries(item[analyticsKey][layerKey]).forEach(([expert, metrics]) => {
                            const existing = experts.find(e => e.expert === expert);
                            if (existing) {
                                existing.totalValue += metrics.count_frequency * weight;
                                existing.totalWeight += weight;
                            } else {
                                experts.push({
                                    expert: expert,
                                    totalValue: metrics.count_frequency * weight,
                                    totalWeight: weight
                                });
                            }
                        });
                    }
                });

                if (experts.length > 0) {
                    const top4 = experts
                        .map(e => ({ expert: e.expert, value: e.totalValue / e.totalWeight }))
                        .sort((a, b) => b.value - a.value)
                        .slice(0, 4);
                    
                    if (top4.length > 0) {
                        layerData[layerKey] = top4;
                    }
                }
            }

            return layerData;
        }

        function createCharts(containerId, data, analyticsKey) {
            const container = document.getElementById(containerId);
            if (!container) return;

            const layerData = getTop4Data(data, analyticsKey);
            
            Object.entries(layerData).forEach(([layerKey, experts]) => {
                const layerNum = layerKey.replace('layer_', '');
                
                // Get all experts for this layer (not just top 4)
                const allExperts = [];
                data.forEach(item => {
                    if (item[analyticsKey] && item[analyticsKey][layerKey]) {
                        const weight = item.sample_count;
                        Object.entries(item[analyticsKey][layerKey]).forEach(([expert, metrics]) => {
                            const existing = allExperts.find(e => e.expert === expert);
                            if (existing) {
                                existing.totalValue += metrics.count_frequency * weight;
                                existing.totalWeight += weight;
                            } else {
                                allExperts.push({
                                    expert: expert,
                                    totalValue: metrics.count_frequency * weight,
                                    totalWeight: weight
                                });
                            }
                        });
                    }
                });

                const chartData = allExperts
                    .map(e => ({ expert: parseInt(e.expert), value: e.totalValue / e.totalWeight }))
                    .sort((a, b) => a.expert - b.expert);

                if (chartData.length > 0) {
                    const chartDiv = document.createElement('div');
                    chartDiv.className = 'layer-chart';
                    chartDiv.innerHTML = `
                        <div style="font-weight: bold; text-align: center; margin-bottom: 10px;">Layer ${layerNum}</div>
                        <canvas id="${containerId}_${layerNum}" width="800" height="150"></canvas>
                    `;
                    container.appendChild(chartDiv);

                    setTimeout(() => {
                        const canvas = document.getElementById(`${containerId}_${layerNum}`);
                        if (canvas) {
                            const colors = chartData.map(item => {
                                const ratio = item.expert / 31;
                                const hue = 270 - (ratio * 150);
                                return `hsla(${hue}, 75%, 50%, 0.8)`;
                            });

                            const chart = new Chart(canvas.getContext('2d'), {
                                type: 'bar',
                                data: {
                                    labels: chartData.map(item => `E${item.expert}`),
                                    datasets: [{
                                        data: chartData.map(item => item.value),
                                        backgroundColor: colors,
                                        borderColor: colors.map(c => c.replace('0.8', '1')),
                                        borderWidth: 1
                                    }]
                                },
                                options: {
                                    responsive: false,
                                    maintainAspectRatio: false,
                                    plugins: { legend: { display: false } },
                                    scales: {
                                        y: { beginAtZero: true },
                                        x: { ticks: { maxRotation: 0 } }
                                    }
                                }
                            });
                            charts.push(chart);
                        }
                    }, 50);
                }
            });
        }

        function setupDownload(buttonId, data, type) {
            const btn = document.getElementById(buttonId);
            if (btn) {
                btn.onclick = () => {
                    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `top4_${type}_${new Date().toISOString().split('T')[0]}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                };
            }
        }

        // Event listeners
        document.getElementById('analyzeBtn').addEventListener('click', analyze);
        
        // Close modal when clicking outside or pressing escape
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('layerModal');
            if (modal && e.target === modal) {
                closeModal();
            }
        });
        
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeModal();
            }
        });

        // Initialize on page load
        window.addEventListener('load', init);
    </script>
</body>
</html>